<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Fogo Ecosystem Tokenomics</title>
  <meta name="description" content="CFO-level live token treasury dashboard for Fogo Foundation" />
  <style>
    :root {
      --bg: #140503;
      --bg2: #220904;
      --panel: rgba(45, 14, 8, 0.76);
      --line: #7a2a16;
      --ink: #fff0ea;
      --muted: #e7b4a3;
      --fire1: #e32300;
      --fire2: #b51200;
      --fire3: #6f0900;
      --amber: #ff8a4d;
      --green: #38e89c;
    }
    * { box-sizing: border-box; }
    html, body { margin:0; padding:0; color:var(--ink); font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    body {
      background: radial-gradient(1000px 600px at 12% -20%, rgba(225,38,0,.28), transparent 70%),
                  radial-gradient(900px 600px at 88% -10%, rgba(155,20,0,.34), transparent 70%),
                  linear-gradient(180deg, var(--bg), var(--bg2));
      min-height: 100vh;
      overflow-x: hidden;
    }
    .fx { position: fixed; inset:0; pointer-events:none; }
    .gridfx { background-image: linear-gradient(rgba(255,129,58,.08) 1px, transparent 1px), linear-gradient(90deg, rgba(255,129,58,.08) 1px, transparent 1px); background-size: 34px 34px; mask-image: radial-gradient(circle at center, black 45%, transparent 100%); opacity:.45; }
    .scan { background: repeating-linear-gradient(to bottom, rgba(255,255,255,.05), rgba(255,255,255,.05) 1px, transparent 2px, transparent 5px); mix-blend-mode: soft-light; opacity:.08; animation: scan 7s linear infinite; }
    @keyframes scan { from { transform: translateY(-15%);} to { transform: translateY(15%);} }

    .wrap { max-width: 1440px; margin: 0 auto; padding: 24px; position: relative; }
    .wrap:before {
      content:"";
      position:absolute;
      right: 4%;
      top: 0;
      width: 360px;
      height: 360px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,59,10,.26), rgba(155,20,0,0) 68%);
      filter: blur(10px);
      animation: lavaOrb 7s ease-in-out infinite;
      pointer-events:none;
    }
    @keyframes lavaOrb { 0%,100% { transform: translateY(0px);} 50% { transform: translateY(14px);} }
    .hero {
      border:1px solid var(--line); border-radius: 22px; background: linear-gradient(150deg, rgba(50,24,12,.94), rgba(23,12,7,.8));
      padding: 24px; box-shadow: 0 24px 60px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.06);
      display: grid; grid-template-columns: 1.2fr .8fr; gap: 18px;
    }
    .brandline { display:flex; align-items:center; gap:12px; margin-bottom: 8px; }
    .fogo-logo { width: 34px; height: 34px; border-radius: 10px; border:1px solid #7e4528; background:#2d140a; padding:4px; box-shadow: 0 0 18px rgba(255,106,0,.25); object-fit: contain; }
    .badge { display:inline-flex; gap:8px; align-items:center; border:1px solid #8e4a2a; border-radius:999px; padding:6px 10px; color:#ffd5c2; font-size:12px; }
    .dot { width:8px; height:8px; border-radius:50%; background:var(--green); box-shadow:0 0 0 rgba(56,232,156,.5); animation:pulse 1.4s infinite; }
    @keyframes pulse { 70% { box-shadow:0 0 0 12px rgba(56,232,156,0);} 100% { box-shadow:0 0 0 0 rgba(56,232,156,0);} }
    h1 { margin:10px 0 8px; font-size:44px; line-height:1; letter-spacing:-.02em; }
    .sub { color:var(--muted); margin:0; }
    .sync { text-align:right; color: var(--muted); font-size:13px; }
    .sync b { color: #ffd8b3; }

    .tape {
      margin-top: 12px;
      border: 1px solid var(--line);
      border-radius: 12px;
      background: rgba(50,18,9,.72);
      overflow: hidden;
      position: relative;
    }
    .tape:before {
      content:"";
      position:absolute; inset:0;
      background: linear-gradient(90deg, rgba(28,9,4,.95), transparent 8%, transparent 92%, rgba(28,9,4,.95));
      pointer-events:none;
      z-index:2;
    }
    .tape-track {
      display: inline-flex;
      align-items: center;
      gap: 20px;
      white-space: nowrap;
      padding: 9px 0;
      width: max-content;
      animation: tapeScroll 34s linear infinite;
      will-change: transform;
    }
    .tape-item {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      color: #ffd9c6;
      font-size: 12px;
      letter-spacing: .03em;
      min-width: 250px;
    }
    .tape-pill {
      border: 1px solid #9b331d;
      border-radius: 999px;
      padding: 2px 8px;
      color: #ffba94;
      font-size: 10px;
      text-transform: uppercase;
      flex: 0 0 auto;
    }
    .trend-up { color: #65f2ae; }
    .trend-down { color: #ff9a8a; }
    @keyframes tapeScroll { from { transform: translate3d(0,0,0);} to { transform: translate3d(-50%,0,0);} }

    .kpi-grid { margin-top:16px; display:grid; grid-template-columns: repeat(6, minmax(0,1fr)); gap: 10px; }
    .kpi { border:1px solid var(--line); border-radius:14px; padding:11px; background:var(--panel); position:relative; overflow:hidden; min-height: 94px; }
    .kpi:before { content:""; position:absolute; inset:0; background:linear-gradient(120deg, transparent 20%, rgba(255,184,128,.12) 45%, transparent 60%); transform:translateX(-120%); animation:sweep 4.5s linear infinite; }
    @keyframes sweep { to { transform: translateX(120%);} }
    .k-label { font-size:11px; text-transform:uppercase; letter-spacing:.08em; color:#ffc8a8; }
    .k-value { font-weight:800; font-size: clamp(18px, 1.45vw, 26px); line-height:1.1; margin-top:6px; font-variant-numeric: tabular-nums; white-space: nowrap; overflow:hidden; text-overflow: ellipsis; text-shadow: 0 0 12px rgba(255,106,0,.22); animation: valuePulse 2.8s ease-in-out infinite; }
    @keyframes valuePulse { 0%,100% { opacity: .95; } 50% { opacity: 1; } }
    .k-sub { font-size:12px; color:#ffc4a0; margin-top:4px; white-space: nowrap; overflow:hidden; text-overflow: ellipsis; }

    .main { margin-top:14px; display:grid; grid-template-columns: 1.1fr .9fr; gap: 12px; align-items: stretch; }
    .card { border:1px solid var(--line); border-radius:16px; background:var(--panel); padding:14px; box-shadow: 0 12px 35px rgba(0,0,0,.4); min-height: 270px; transition: transform .22s ease, box-shadow .22s ease, border-color .22s ease; }
    .card:hover { transform: translateY(-2px); border-color:#a83a20; box-shadow: 0 16px 40px rgba(0,0,0,.46), 0 0 0 1px rgba(255,106,0,.16) inset; }
    .card h3 { margin:0 0 10px; font-size:16px; letter-spacing:.02em; color:#ffe7d8; }

    table { width:100%; border-collapse: collapse; font-size:13px; }
    th, td { border-bottom:1px solid rgba(168,94,56,.45); padding:9px 6px; text-align:right; font-variant-numeric: tabular-nums; }
    th:first-child, td:first-child { text-align:left; }

    .sparkline { width:100%; height:165px; border:1px solid #7f4428; border-radius:12px; background: rgba(33,16,10,.78); }
    .throughput-meta { margin-top:8px; display:flex; justify-content:space-between; color:#ffc09e; font-size:12px; }
    .realtime-strip { margin-top:10px; height:10px; border-radius:999px; background:rgba(124,70,44,.45); overflow:hidden; }
    .realtime-strip > div { height:100%; width:30%; background: linear-gradient(90deg,var(--fire2),var(--fire3)); box-shadow: 0 0 14px rgba(255,106,0,.55); animation: flow 1.2s linear infinite; }
    @keyframes flow { from { transform: translateX(-120%);} to { transform: translateX(340%);} }

    .bars { display:grid; gap:10px; }
    .bar-row { display:grid; grid-template-columns: 130px 1fr 90px; gap:10px; align-items:center; font-size:13px; }
    .bar-track { height:9px; background:rgba(124,70,44,.45); border-radius:999px; overflow:hidden; }
    .bar-fill { height:100%; background: linear-gradient(90deg, var(--fire2), var(--fire1), var(--fire3)); border-radius:999px; transition: width .6s ease; box-shadow: 0 0 12px rgba(255,106,0,.45); }

    .wallet-grid { display:grid; grid-template-columns: 1fr auto; gap:10px; margin-bottom:10px; }
    input { width:100%; border:1px solid #914c2b; border-radius:10px; background:#2a140a; color:#fff1e9; padding:10px; }
    button { border:none; border-radius:10px; background:linear-gradient(90deg,var(--fire2),#ffb173); color:#2d1307; font-weight:700; padding:10px 14px; cursor:pointer; }
    .muted { color: var(--muted); font-size:12px; }

    @media (max-width:1200px){ .kpi-grid { grid-template-columns: repeat(3,1fr);} .hero,.main { grid-template-columns:1fr; } }
    @media (max-width:700px){ .kpi-grid { grid-template-columns: repeat(2,1fr);} h1{font-size:34px;} .wrap{padding:14px;} }
  </style>
</head>
<body>
  <div class="fx gridfx"></div>
  <div class="fx scan"></div>
  <div class="wrap">
    <section class="hero">
      <div>
        <div class="brandline">
          <img class="fogo-logo" src="./fogo-logo.png" alt="Fogo logo" />
          <span class="badge"><span class="dot"></span> Fogo Foundation • Connection Live</span>
        </div>
        <h1>Fogo Ecosystem Tokenomics</h1>
        <p class="sub">Live tokenomics, chain throughput, supply diagnostics, validator concentration and treasury wallet monitoring.</p>
      </div>
      <div class="sync">
        <div>Last sync: <b id="lastSync">--:--:--</b></div>
        <div id="syncAge">Live feed warming up…</div>
        <div style="margin-top:8px" class="muted">Data sources: Fogo Mainnet RPC, CoinGecko, DeFiLlama</div>
      </div>
    </section>

    <section class="tape">
      <div class="tape-track" id="tapeTrack">
        <span class="tape-item"><span class="tape-pill">Price</span><span data-k="price">FOGO —</span></span>
        <span class="tape-item"><span class="tape-pill">Trend</span><span data-k="trend">—</span></span>
        <span class="tape-item"><span class="tape-pill">TPS</span><span data-k="tps">—</span></span>
        <span class="tape-item"><span class="tape-pill">Txns Window</span><span data-k="txWindow">—</span></span>
        <span class="tape-item"><span class="tape-pill">MCap</span><span data-k="mcap">—</span></span>
        <span class="tape-item"><span class="tape-pill">TVL</span><span data-k="tvl">—</span></span>
        <span class="tape-item"><span class="tape-pill">Stake Ratio</span><span data-k="stakeRatio">—</span></span>
        <span class="tape-item"><span class="tape-pill">Epoch</span><span data-k="epoch">—</span></span>
      </div>
    </section>

    <section class="kpi-grid">
      <div class="kpi"><div class="k-label">Token Price</div><div class="k-value" id="price">—</div><div class="k-sub" id="chg">—</div></div>
      <div class="kpi"><div class="k-label">Market Cap</div><div class="k-value" id="mcap">—</div><div class="k-sub">USD</div></div>
      <div class="kpi"><div class="k-label">FDV</div><div class="k-value" id="fdv">—</div><div class="k-sub">USD</div></div>
      <div class="kpi"><div class="k-label">24h Volume</div><div class="k-value" id="vol">—</div><div class="k-sub">USD</div></div>
      <div class="kpi"><div class="k-label">Circulating Supply</div><div class="k-value" id="circ">—</div><div class="k-sub" id="supplyRatio">—</div></div>
      <div class="kpi"><div class="k-label">TVL</div><div class="k-value" id="tvl">—</div><div class="k-sub">DeFiLlama</div></div>

      <div class="kpi"><div class="k-label">Live TPS</div><div class="k-value" id="tps">—</div><div class="k-sub">Transactions / second</div></div>
      <div class="kpi"><div class="k-label">Txns (Sample Window)</div><div class="k-value" id="tx24">—</div><div class="k-sub" id="txWindowMeta">Exact sum from live performance samples</div></div>
      <div class="kpi"><div class="k-label">Cumulative Txns</div><div class="k-value" id="txTotal">—</div><div class="k-sub">From epoch info</div></div>
      <div class="kpi"><div class="k-label">Current Epoch</div><div class="k-value" id="epoch">—</div><div class="k-sub" id="epochProgress">—</div></div>
      <div class="kpi"><div class="k-label">Total Stake</div><div class="k-value" id="stake">—</div><div class="k-sub" id="stakingRatio">—</div></div>
      <div class="kpi"><div class="k-label">Validators</div><div class="k-value" id="validators">—</div><div class="k-sub">Active vote accounts</div></div>
    </section>

    <section class="main">
      <div class="card">
        <h3>Real-Time Throughput Signal</h3>
        <canvas id="spark" class="sparkline" width="900" height="210"></canvas>
        <div class="throughput-meta"><span id="sparkMin">Min: —</span><span id="sparkNow">Now: — TPS</span><span id="sparkMax">Max: —</span></div>
        <div class="realtime-strip"><div></div></div>
        <div class="muted" style="margin-top:8px">Graph updates every 1 second using live performance samples from Fogo mainnet RPC.</div>
      </div>
      <div class="card">
        <h3>Supply Composition</h3>
        <div class="bars">
          <div class="bar-row"><div>Circulating</div><div class="bar-track"><div id="barCirc" class="bar-fill" style="width:0%"></div></div><div id="txtCirc">—</div></div>
          <div class="bar-row"><div>Non-Circulating</div><div class="bar-track"><div id="barNonCirc" class="bar-fill" style="width:0%"></div></div><div id="txtNonCirc">—</div></div>
          <div class="bar-row"><div>Staked</div><div class="bar-track"><div id="barStaked" class="bar-fill" style="width:0%"></div></div><div id="txtStaked">—</div></div>
          <div class="bar-row"><div>Burned</div><div class="bar-track"><div id="barBurned" class="bar-fill" style="width:0%"></div></div><div id="txtBurned">—</div></div>
        </div>
        <div style="margin-top:12px">
          <div style="font-size:12px;color:#ffc4a0;margin-bottom:6px">Ecosystem Allocation</div>
          <canvas id="allocPie" width="420" height="220" style="width:100%;height:220px;border:1px solid #7f4428;border-radius:12px;background:rgba(33,16,10,.62)"></canvas>
        </div>
      </div>
    </section>

    <section class="main">
      <div class="card">
        <h3>Validator Concentration Snapshot</h3>
        <table>
          <thead><tr><th>Validator Operator</th><th>Activated Stake</th><th>Share</th></tr></thead>
          <tbody id="validatorRows"><tr><td colspan="3">Loading…</td></tr></tbody>
        </table>
      </div>
      <div class="card">
        <h3>Treasury Wallet Monitor (Foundation)</h3>
        <div class="wallet-grid">
          <input id="walletInput" placeholder="Paste Fogo wallet address and press Add" />
          <button id="addWallet">Add</button>
        </div>
        <table>
          <thead><tr><th>Wallet</th><th>Balance (FOGO)</th><th>USD Value</th></tr></thead>
          <tbody id="walletRows"><tr><td colspan="3">No wallets added yet.</td></tr></tbody>
        </table>
      </div>
    </section>

    <section class="main">
      <div class="card">
        <h3>Onchain Revenue & Inflation (Live)</h3>
        <div style="display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:10px">
          <div style="border:1px solid #7f4428;border-radius:12px;padding:10px;background:rgba(33,16,10,.56)"><div style="font-size:11px;color:#ffc4a0;text-transform:uppercase">Revenue (Exact Fee Sum)</div><div id="revValue" style="font-size:26px;font-weight:800;margin-top:4px">—</div><div id="revMeta" style="font-size:12px;color:#ffc4a0">—</div></div>
          <div style="border:1px solid #7f4428;border-radius:12px;padding:10px;background:rgba(33,16,10,.56)"><div style="font-size:11px;color:#ffc4a0;text-transform:uppercase">Inflation (Annualized)</div><div id="inflValue" style="font-size:26px;font-weight:800;margin-top:4px">—</div><div id="inflMeta" style="font-size:12px;color:#ffc4a0">—</div></div>
        </div>
      </div>
      <div class="card">
        <h3>Monetary Change Tracker</h3>
        <div style="border:1px solid #7f4428;border-radius:12px;padding:12px;background:rgba(33,16,10,.56)">
          <div style="font-size:11px;color:#ffc4a0;text-transform:uppercase">Inflation Since Dashboard Open</div>
          <div id="inflSinceOpen" style="font-size:30px;font-weight:900;margin-top:4px">—</div>
          <div id="inflUsdSinceOpen" style="font-size:13px;color:#ffc4a0">—</div>
        </div>
      </div>
    </section>
  </div>

  <script>
    const state = {
      lastSyncMs: null,
      tpsSeries: [],
      wallets: JSON.parse(localStorage.getItem('fogo_wallets') || '[]'),
      liveTps: null,
      txTotal: null,
      lastTickTs: Date.now(),
      market: { price: null, pricePrev: null, mcap: null, fdv: null, vol: null, chg24: null, totalSupply: null },
      network: { tvl: null, epoch: null, epochProgress: null, stakeRatio: null },
      txWindowCount: null,
      txWindowSecs: null,
      revenueFogo: null,
      revenueUsd: null,
      revenueSlots: null,
      inflationRate: null,
      inflationFogoYear: null,
      inflationUsdYear: null,
      inflationSinceOpenFogo: 0,
      supplyBaseline: null,
      validatorNameMap: {},
      observedFees: [],
      totalSupplyCurrent: null,
      openTs: Date.now()
    };
    const el = (id) => document.getElementById(id);
    const fmtUsd = (n) => (n == null || !isFinite(n)) ? '—' : new Intl.NumberFormat('en-US', { style:'currency', currency:'USD', notation: n > 1e9 ? 'compact' : 'standard', maximumFractionDigits: 2 }).format(n);
    const fmtUsdPrice = (n) => (n == null || !isFinite(n)) ? '—' : `$${Number(n).toLocaleString('en-US', { minimumFractionDigits: 4, maximumFractionDigits: 4 })}`;
    const fmtNum = (n) => (n == null || !isFinite(n)) ? '—' : new Intl.NumberFormat('en-US', { maximumFractionDigits: 2 }).format(n);
    const fmtCompact = (n) => (n == null || !isFinite(n)) ? '—' : new Intl.NumberFormat('en-US', { notation:'compact', maximumFractionDigits: 2 }).format(n);

    function setTapeValue(key, html) {
      document.querySelectorAll(`[data-k="${key}"]`).forEach(n => n.innerHTML = html);
    }

    function initTapeLoop() {
      const track = el('tapeTrack');
      track.innerHTML += track.innerHTML;
    }

    async function rpc(method, params=[]) {
      const r = await fetch('https://mainnet.fogo.io', { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({jsonrpc:'2.0', id:1, method, params}) });
      const j = await r.json();
      return j.result;
    }
    async function fetchMarket() { const r = await fetch('https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=fogo&price_change_percentage=24h', { cache:'no-store' }); const j = await r.json(); return Array.isArray(j) ? j[0] : null; }
    async function fetchTvl() { const r = await fetch('https://api.llama.fi/v2/chains', { cache:'no-store' }); const j = await r.json(); const fogo = (Array.isArray(j) ? j.find(x => x.name === 'Fogo') : null) || null; return fogo?.tvl ?? null; }

    async function fetchValidatorNameMap() {
      try {
        const rows = await rpc('getProgramAccounts', ['Config1111111111111111111111111111111111111', { encoding: 'jsonParsed' }]);
        const map = {};
        (rows || []).forEach((r) => {
          const info = r?.account?.data?.parsed?.info;
          if (r?.account?.data?.parsed?.type !== 'validatorInfo') return;
          const key = (info?.keys || []).find((k) => k?.signer === true)?.pubkey;
          const name = info?.configData?.name;
          if (key && name) map[key] = name;
        });
        state.validatorNameMap = map;
      } catch {}
    }

    async function fetchRevenueAndInflation() {
      try {
        const [slot, infl] = await Promise.all([
          rpc('getSlot', []),
          rpc('getInflationRate', [])
        ]);

        const block = await rpc('getBlock', [slot, { transactionDetails: 'full', rewards: false, maxSupportedTransactionVersion: 0 }]);
        const feesLamports = (block?.transactions || []).reduce((a, t) => a + Number(t?.meta?.fee || 0), 0);
        const feesFogo = feesLamports / 1e9;
        state.revenueFogo = feesFogo;
        state.revenueUsd = (state.market.price != null) ? feesFogo * state.market.price : null;
        state.revenueSlots = 1;

        state.observedFees.push({ t: Date.now(), fogo: feesFogo });
        state.observedFees = state.observedFees.filter((x) => Date.now() - x.t <= 3600_000);

        state.inflationRate = infl?.total ?? null;
        if (state.inflationRate != null && state.supplyBaseline != null) {
          state.inflationFogoYear = state.supplyBaseline * state.inflationRate;
          state.inflationUsdYear = (state.market.price != null) ? state.inflationFogoYear * state.market.price : null;
        }
      } catch {}
    }

    function updateSync() { if (!state.lastSyncMs) return; const s = Math.floor((Date.now() - state.lastSyncMs) / 1000); el('syncAge').textContent = `Last pull ${s}s ago • Live lane updates every 1s`; }

    function drawSpark() {
      const cvs = el('spark'); const ctx = cvs.getContext('2d'); const arr = state.tpsSeries.slice(-100);
      ctx.clearRect(0,0,cvs.width,cvs.height); ctx.fillStyle = 'rgba(33,16,10,.78)'; ctx.fillRect(0,0,cvs.width,cvs.height);
      if (!arr.length) return;
      const min = Math.min(...arr), max = Math.max(...arr), span = (max-min)||1;
      const pad=22, w=cvs.width-pad*2, h=cvs.height-pad*2;
      ctx.strokeStyle='rgba(174,97,57,.45)'; ctx.lineWidth=1;
      for(let i=0;i<5;i++){ const y = pad + (h/4)*i; ctx.beginPath(); ctx.moveTo(pad,y); ctx.lineTo(pad+w,y); ctx.stroke();
        const val = (max - (span/4)*i); ctx.fillStyle='rgba(255,185,145,.72)'; ctx.font='11px Inter'; ctx.fillText(val.toFixed(1), 4, y+4);
      }
      ctx.beginPath();
      arr.forEach((v,i)=>{ const x = pad + (i/(arr.length-1||1))*w; const y = pad + h - ((v-min)/span)*h; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); });
      ctx.strokeStyle = '#ff8a00'; ctx.lineWidth=2.6; ctx.shadowBlur=14; ctx.shadowColor='rgba(255,106,0,.7)'; ctx.stroke(); ctx.shadowBlur=0;
      const last = arr[arr.length-1]; const x = pad + w, y = pad + h - ((last-min)/span)*h; ctx.beginPath(); ctx.arc(x,y,5,0,Math.PI*2); ctx.fillStyle='#ffd16f'; ctx.fill();
      el('sparkMin').textContent = `Min: ${min.toFixed(2)} TPS`; el('sparkNow').textContent = `Now: ${last.toFixed(2)} TPS`; el('sparkMax').textContent = `Max: ${max.toFixed(2)} TPS`;
    }

    function setBars(circ, total, staked, burned) {
      if (!total || !isFinite(total)) return;
      const pCirc = Math.max(0, Math.min(100, ((circ||0)/total)*100));
      const pSt = Math.max(0, Math.min(100, ((staked||0)/total)*100));
      const pBurn = Math.max(0, Math.min(100, ((burned||0)/total)*100));
      const pNon = Math.max(0, 100 - pCirc - pBurn);
      el('barCirc').style.width = pCirc + '%';
      el('barCirc').style.background = 'linear-gradient(90deg,#ff8a4d,#ffb36d)';
      el('barNonCirc').style.width = pNon + '%';
      el('barNonCirc').style.background = 'linear-gradient(90deg,#c52812,#8a1408)';
      el('barStaked').style.width = pSt + '%';
      el('barStaked').style.background = 'linear-gradient(90deg,#ffbe67,#ffd089)';
      el('barBurned').style.width = pBurn + '%';
      el('barBurned').style.background = 'linear-gradient(90deg,#5a0a00,#2d0300)';
      el('txtCirc').textContent = pCirc.toFixed(2)+'%';
      el('txtNonCirc').textContent = pNon.toFixed(2)+'%';
      el('txtStaked').textContent = pSt.toFixed(2)+'%';
      el('txtBurned').textContent = pBurn.toFixed(2)+'%';
    }

    function drawAllocationPie({circ, nonCirc, burned, staked=0}) {
      const cvs = el('allocPie'); if (!cvs) return;
      const dpr = Math.min(2, window.devicePixelRatio || 1);
      const cssW = Math.max(360, cvs.clientWidth || 420);
      const cssH = 220;
      if (cvs.width !== Math.floor(cssW * dpr) || cvs.height !== Math.floor(cssH * dpr)) {
        cvs.width = Math.floor(cssW * dpr);
        cvs.height = Math.floor(cssH * dpr);
        cvs.style.width = cssW + 'px';
        cvs.style.height = cssH + 'px';
      }
      const ctx = cvs.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0);
      ctx.clearRect(0,0,cssW,cssH);
      ctx.imageSmoothingEnabled = true;

      const cx = Math.min(130, cssW * 0.29), cy = cssH/2 - 2, r = 76, depth = 16;
      const parts = [
        {k:'Circulating',v:Math.max(0,circ||0),c1:'#ff9a5b',c2:'#ff5a24'},
        {k:'Non-Circulating',v:Math.max(0,nonCirc||0),c1:'#d33117',c2:'#8f1408'},
        {k:'Burned',v:Math.max(0,burned||0),c1:'#5d0b00',c2:'#2a0300'},
        {k:'Staked',v:Math.max(0,staked||0),c1:'#ffd07e',c2:'#ffab57'}
      ];
      const total = parts.reduce((a,b)=>a+b.v,0) || 1;
      const tilt = 0.72;
      const startRot = -Math.PI/2;

      // shadow base
      ctx.beginPath();
      ctx.ellipse(cx, cy + depth + 8, r*0.98, r*tilt*0.95, 0, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(0,0,0,.35)';
      ctx.fill();

      // depth ring
      let a0 = startRot;
      parts.forEach((p)=>{
        const da = (p.v/total)*Math.PI*2;
        ctx.beginPath();
        ctx.ellipse(cx, cy + depth, r, r*tilt, 0, a0, a0+da);
        ctx.lineTo(cx, cy + depth);
        ctx.closePath();
        ctx.fillStyle = 'rgba(70,20,12,.66)';
        ctx.fill();
        a0 += da;
      });

      // top ring
      a0 = startRot;
      parts.forEach((p,i)=>{
        const da = (p.v/total)*Math.PI*2;
        const g = ctx.createLinearGradient(cx-r, cy-r, cx+r, cy+r);
        g.addColorStop(0,p.c1); g.addColorStop(1,p.c2);

        ctx.beginPath();
        ctx.ellipse(cx, cy, r, r*tilt, 0, a0, a0+da);
        ctx.lineTo(cx, cy);
        ctx.closePath();
        ctx.fillStyle = g;
        ctx.fill();
        ctx.strokeStyle = 'rgba(35,8,6,.38)';
        ctx.lineWidth = 1;
        ctx.stroke();

        // glossy highlight
        const mid = a0 + da/2;
        const hx = cx + Math.cos(mid) * r*0.58;
        const hy = cy + Math.sin(mid) * r*tilt*0.58;
        const hg = ctx.createRadialGradient(hx,hy,1,hx,hy,16);
        hg.addColorStop(0,'rgba(255,255,255,.28)');
        hg.addColorStop(1,'rgba(255,255,255,0)');
        ctx.beginPath();
        ctx.ellipse(hx, hy, 18, 10, 0, 0, Math.PI*2);
        ctx.fillStyle = hg;
        ctx.fill();

        a0 += da;

        const ly = 26 + i*28;
        const lx = Math.max(228, cssW*0.56);
        ctx.fillStyle = p.c1;
        ctx.fillRect(lx, ly, 12, 12);
        ctx.fillStyle = '#ffd8c3';
        ctx.font = '12px Inter';
        ctx.fillText(`${p.k}: ${((p.v/total)*100).toFixed(1)}%`, lx + 18, ly + 11);
      });

      // donut core + inner glow
      ctx.beginPath();
      ctx.ellipse(cx, cy, 30, 22, 0, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(28,9,7,.94)';
      ctx.fill();
      const ig = ctx.createRadialGradient(cx,cy,2,cx,cy,34);
      ig.addColorStop(0,'rgba(255,146,96,.35)');
      ig.addColorStop(1,'rgba(255,146,96,0)');
      ctx.beginPath();
      ctx.ellipse(cx, cy, 35, 26, 0, 0, Math.PI*2);
      ctx.fillStyle = ig;
      ctx.fill();
    }


    async function refreshWallets(price) {
      const body = el('walletRows'); if (!state.wallets.length) { body.innerHTML = '<tr><td colspan="3">No wallets added yet.</td></tr>'; return; }
      const rows = await Promise.all(state.wallets.map(async (w) => { try { const lamports = await rpc('getBalance', [w, {commitment:'confirmed'}]).then(x=>x?.value); return { w, bal:(lamports||0)/1e9 }; } catch { return { w, bal:null }; } }));
      body.innerHTML = rows.map(r => `<tr><td style="max-width:280px;overflow:hidden;text-overflow:ellipsis">${r.w}</td><td>${fmtNum(r.bal)}</td><td>${r.bal == null || !price ? '—' : fmtUsd(r.bal * price)}</td></tr>`).join('');
    }

    async function refreshValidatorNames() {
      try {
        const accounts = await rpc('getProgramAccounts', ['Config1111111111111111111111111111111111111', { encoding: 'jsonParsed' }]);
        const map = {};
        (Array.isArray(accounts) ? accounts : []).forEach((a) => {
          const info = a?.account?.data?.parsed?.info;
          const cfg = info?.configData;
          const keys = info?.keys;
          const identity = Array.isArray(keys) ? keys.find(k => k?.signer && k?.pubkey !== 'Va1idator1nfo111111111111111111111111111111')?.pubkey : null;
          if (identity && cfg?.name) map[identity] = cfg.name;
        });
        state.validatorNameMap = map;
      } catch {
        state.validatorNameMap = state.validatorNameMap || {};
      }
    }

    async function refreshRevenueAndInflation() {
      try {
        const [slot, inflation] = await Promise.all([rpc('getSlot', []), rpc('getInflationRate', [])]);
        const slots = Array.from({length: 40}, (_,i) => slot - i).filter(s => s > 0);
        const feeCalls = await Promise.all(slots.map(async (s) => {
          try {
            const b = await rpc('getBlock', [s, { transactionDetails: 'none', rewards: true, maxSupportedTransactionVersion: 0 }]);
            const feeLamports = (b?.rewards || []).filter(r => r?.rewardType === 'Fee').reduce((a,r)=>a + Number(r?.lamports || 0), 0);
            return feeLamports;
          } catch { return 0; }
        }));

        const totalLamports = feeCalls.reduce((a,b)=>a+b,0);
        state.revenueFogo = totalLamports / 1e9;
        state.revenueUsd = state.market.price != null ? state.revenueFogo * state.market.price : null;
        state.revenueSlots = slots.length;

        state.inflationRate = inflation?.total ?? null;
      } catch {
        // keep previous values
      }
    }

    async function refreshFull() {
      try {
        if (!Object.keys(state.validatorNameMap).length) await fetchValidatorNameMap();
        const [market, tvl, epoch, vote, supply] = await Promise.all([fetchMarket(), fetchTvl(), rpc('getEpochInfo', []), rpc('getVoteAccounts', []), rpc('getSupply', [{commitment:'confirmed'}])]);
        await fetchRevenueAndInflation();
        const circ = market?.circulating_supply ?? null;
        const totalSupply = market?.total_supply ?? supply?.value?.total / 1e9 ?? null;
        state.totalSupplyCurrent = totalSupply;
        if (totalSupply && !state.supplyBaseline) state.supplyBaseline = totalSupply;
        const maxSupply = market?.max_supply ?? null;
        const burned = (maxSupply && totalSupply) ? Math.max(0, maxSupply - totalSupply) : 0;
        const activeVotes = vote?.current || [];
        const totalStakeLamports = activeVotes.reduce((a,v)=> a + Number(v.activatedStake || 0), 0);
        const totalStake = totalStakeLamports / 1e9;

        state.market.pricePrev = state.market.price;
        state.market.price = market?.current_price ?? state.market.price;
        state.market.chg24 = market?.price_change_percentage_24h ?? state.market.chg24;
        state.market.mcap = market?.market_cap ?? state.market.mcap;
        state.market.fdv = market?.fully_diluted_valuation ?? state.market.fdv;
        state.market.vol = market?.total_volume ?? state.market.vol;
        state.market.totalSupply = totalSupply ?? state.market.totalSupply;

        el('chg').innerHTML = state.market.chg24 != null ? `<span class="${state.market.chg24 >= 0 ? 'trend-up' : 'trend-down'}">${state.market.chg24 >= 0 ? '▲' : '▼'} ${state.market.chg24.toFixed(2)}% (24h)</span>` : '—';
        el('circ').textContent = fmtCompact(circ);
        el('supplyRatio').textContent = (circ && totalSupply) ? `${((circ/totalSupply)*100).toFixed(2)}% of total supply` : '—';

        if (epoch?.transactionCount) state.txTotal = Number(epoch.transactionCount);
        const epochProgress = epoch?.slotsInEpoch ? ((epoch.slotIndex/epoch.slotsInEpoch)*100) : null;
        state.network.tvl = tvl;
        state.network.epoch = epoch?.epoch ?? null;
        state.network.epochProgress = epochProgress;
        state.network.stakeRatio = totalSupply ? ((totalStake/totalSupply)*100) : null;

        if (totalSupply && state.supplyBaseline == null) state.supplyBaseline = totalSupply;

        el('epoch').textContent = epoch?.epoch ?? '—';
        el('epochProgress').textContent = epochProgress != null ? `${epochProgress.toFixed(2)}% through epoch` : '—';
        el('stake').textContent = fmtCompact(totalStake);
        el('stakingRatio').textContent = totalSupply ? `${((totalStake/totalSupply)*100).toFixed(2)}% staking ratio` : '—';
        el('validators').textContent = activeVotes.length || '—';
        const nonCircAbs = Math.max(0, (totalSupply || 0) - (circ || 0));
        setBars(circ, totalSupply, totalStake, burned);
        drawAllocationPie({ circ: circ || 0, nonCirc: nonCircAbs, burned: burned || 0, staked: totalStake || 0 });
        const top = [...activeVotes].sort((a,b)=>Number(b.activatedStake||0)-Number(a.activatedStake||0)).slice(0,10);
        el('validatorRows').innerHTML = top.map(v=>{
          const stake = Number(v.activatedStake||0)/1e9;
          const share = totalStake ? (stake/totalStake)*100 : 0;
          const op = state.validatorNameMap[v.nodePubkey] || `${(v.nodePubkey||'').slice(0,6)}…${(v.nodePubkey||'').slice(-6)}`;
          return `<tr><td>${op}</td><td>${fmtCompact(stake)}</td><td>${share.toFixed(2)}%</td></tr>`;
        }).join('') || '<tr><td colspan="3">No validator data</td></tr>';
        await refreshWallets(market?.current_price || null);
        renderFromState();
        const now = Date.now(); state.lastSyncMs = now; el('lastSync').textContent = new Date(now).toLocaleTimeString(); updateSync();
      } catch { el('syncAge').textContent = 'Data fetch error. Retrying automatically…'; }
    }

    function renderFromState() {
      const trend24 = state.market.chg24 != null ? `${state.market.chg24 >= 0 ? '▲' : '▼'} ${Math.abs(state.market.chg24).toFixed(2)}%` : '—';
      const up = (state.market.chg24 || 0) >= 0;

      el('price').innerHTML = `${fmtUsdPrice(state.market.price)} <span class="${up ? 'trend-up' : 'trend-down'}">${up ? '▲' : '▼'}</span>`;
      el('mcap').textContent = fmtUsd(state.market.mcap);
      el('fdv').textContent = fmtUsd(state.market.fdv);
      el('vol').textContent = fmtUsd(state.market.vol);
      el('tps').textContent = state.liveTps != null ? fmtNum(state.liveTps) : '—';
      el('tx24').textContent = state.txWindowCount != null ? fmtCompact(state.txWindowCount) : '—';
      el('txWindowMeta').textContent = state.txWindowSecs ? `Exact sum over last ${(state.txWindowSecs/60).toFixed(0)} min sample window` : 'Exact sum from live performance samples';
      el('txTotal').textContent = fmtCompact(state.txTotal);

      const rev1hFogo = state.observedFees.reduce((a,b)=>a+b.fogo,0);
      const rev1hUsd = state.market.price != null ? rev1hFogo * state.market.price : null;
      el('revValue').textContent = state.revenueUsd != null ? fmtUsd(state.revenueUsd) : '—';
      el('revMeta').textContent = `Exact fee sum from latest finalized block • 1h observed: ${rev1hUsd != null ? fmtUsd(rev1hUsd) : '—'}`;

      const inflPct = state.inflationRate != null ? (state.inflationRate * 100) : null;
      const annualTokens = state.inflationFogoYear;
      const annualUsd = state.inflationUsdYear;
      el('inflValue').textContent = inflPct != null ? `${inflPct.toFixed(2)}%` : '—';
      el('inflMeta').textContent = annualUsd != null ? `≈ ${fmtUsd(annualUsd)} annualized` : 'Annualized from onchain inflation rate';

      const elapsedYears = (Date.now() - state.openTs) / (365*24*3600*1000);
      const inflSince = annualTokens != null ? Math.max(0, annualTokens * elapsedYears) : null;
      const inflSinceUsd = (inflSince != null && state.market.price != null) ? inflSince * state.market.price : null;
      el('inflSinceOpen').textContent = inflSince != null ? `${fmtCompact(inflSince)} FOGO` : 'Tracking...';
      el('inflUsdSinceOpen').textContent = inflSinceUsd != null ? `${fmtUsd(inflSinceUsd)} since open` : 'USD equivalent updates live';

      setTapeValue('price', `FOGO ${fmtUsdPrice(state.market.price)}`);
      setTapeValue('trend', `<span class="${up ? 'trend-up' : 'trend-down'}">${trend24}</span>`);
      setTapeValue('tps', state.liveTps != null ? `${state.liveTps.toFixed(2)} TPS` : '—');
      setTapeValue('txWindow', state.txWindowCount != null ? `${fmtCompact(state.txWindowCount)} / ${state.txWindowSecs ? (state.txWindowSecs/60).toFixed(0) : '—'}m` : '—');
      setTapeValue('mcap', fmtUsd(state.market.mcap));
      setTapeValue('tvl', fmtUsd(state.network.tvl));
      setTapeValue('stakeRatio', state.network.stakeRatio != null ? `${state.network.stakeRatio.toFixed(2)}%` : '—');
      setTapeValue('epoch', state.network.epoch != null ? `#${state.network.epoch} • ${state.network.epochProgress?.toFixed?.(2) ?? '—'}%` : '—');
    }

    async function refreshLiveLane() {
      try {
        const [perf, epoch] = await Promise.all([
          rpc('getRecentPerformanceSamples', [10]),
          rpc('getEpochInfo', [])
        ]);

        const samples = Array.isArray(perf) ? perf : [];
        const totalTx = samples.reduce((a,s)=>a + Number(s?.numTransactions || 0),0);
        const totalSecs = samples.reduce((a,s)=>a + Number(s?.samplePeriodSecs || 0),0);
        const tps = totalTx && totalSecs ? totalTx / totalSecs : null;

        state.txWindowCount = totalTx || null;
        state.txWindowSecs = totalSecs || null;

        if (tps && isFinite(tps)) {
          state.liveTps = tps;
          state.tpsSeries.push(tps);
          if (state.tpsSeries.length > 160) state.tpsSeries.shift();
        }

        if (epoch?.transactionCount) state.txTotal = Number(epoch.transactionCount);
        await fetchRevenueAndInflation();
      } catch {}

      renderFromState();
      updateSync();
      drawSpark();
    }

    el('addWallet').addEventListener('click', () => { const w = el('walletInput').value.trim(); if (!w) return; if (!state.wallets.includes(w)) state.wallets.push(w); localStorage.setItem('fogo_wallets', JSON.stringify(state.wallets)); el('walletInput').value = ''; refreshFull(); });

    initTapeLoop();
    refreshValidatorNames();
    refreshRevenueAndInflation();
    refreshFull();
    refreshLiveLane();
    setInterval(refreshLiveLane, 1000);
    setInterval(refreshFull, 5000);
    setInterval(refreshRevenueAndInflation, 5000);
    setInterval(refreshValidatorNames, 30000);
  </script>
</body>
</html>